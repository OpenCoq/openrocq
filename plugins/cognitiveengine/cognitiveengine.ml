(* Main cognitive engine plugin interface *)

(** Main cognitive engine *)
type cognitive_engine = {
  atomspace : Hypergraph.atomspace;
  task_scheduler : Taskscheduler.task_scheduler;
  ecan_allocator : Ecan.ecan_allocator;
  pln_engine : Reasoning.pln_engine;
  moses_engine : Reasoning.moses_engine option;
  metacognitive_engine : Metacognition.metacognitive_engine;
}

(** Create a new cognitive engine *)
let create_cognitive_engine () =
  let atomspace = Hypergraph.create_atomspace () in
  let task_scheduler = Taskscheduler.create_scheduler 4 in
  let ecan_allocator = Ecan.create_ecan_allocator atomspace Ecan.default_ecan_config in
  let pln_engine = Reasoning.create_pln_engine atomspace in
  let metacognitive_engine = Metacognition.create_metacognitive_engine atomspace task_scheduler ecan_allocator pln_engine in

  {
    atomspace;
    task_scheduler;
    ecan_allocator;
    pln_engine;
    moses_engine = None;
    metacognitive_engine;
  }

(** Add a concept to the atomspace *)
let add_concept engine name =
  let node = Hypergraph.add_node engine.atomspace name in
  node.id

(** Add a relationship between concepts *)
let add_relationship engine source_id target_id relation_type =
  let link = Hypergraph.add_link engine.atomspace [source_id] [target_id] relation_type in
  link.id

(** Query concepts by name *)
let query_concepts engine name =
  let nodes = Hypergraph.find_nodes_by_name engine.atomspace name in
  List.map (fun node -> node.id) nodes

(** Perform reasoning inference *)
let perform_reasoning engine rule premises =
  Reasoning.perform_pln_inference engine.pln_engine rule premises

(** Schedule a cognitive task *)
let schedule_cognitive_task engine name priority description estimated_duration =
  let task = Taskscheduler.add_task engine.task_scheduler name priority description estimated_duration [] [] in
  Taskscheduler.schedule_tasks engine.task_scheduler;
  task

(** Update attention for concept *)
let update_concept_attention engine concept_id boost_amount =
  Ecan.update_attention_on_access engine.ecan_allocator concept_id boost_amount

(** Get attention focus *)
let get_cognitive_focus engine n =
  Ecan.get_attention_focus engine.ecan_allocator n

(** Trigger meta-cognitive cycle *)
let trigger_metacognitive_cycle engine =
  Metacognition.trigger_introspection_cycle engine.metacognitive_engine

(** Get engine statistics *)
let get_engine_statistics engine =
  let stats = Hashtbl.create 16 in

  (* AtomSpace statistics *)
  Hashtbl.add stats "node_count" (float_of_int (Hashtbl.length engine.atomspace.nodes));
  Hashtbl.add stats "link_count" (float_of_int (Hashtbl.length engine.atomspace.links));
  Hashtbl.add stats "tensor_count" (float_of_int (Hashtbl.length engine.atomspace.tensors));

  (* Task scheduler statistics *)
  let (pending, running, completed, failed, cancelled) = Taskscheduler.get_task_statistics engine.task_scheduler in
  Hashtbl.add stats "tasks_pending" (float_of_int pending);
  Hashtbl.add stats "tasks_running" (float_of_int running);
  Hashtbl.add stats "tasks_completed" (float_of_int completed);
  Hashtbl.add stats "tasks_failed" (float_of_int failed);
  Hashtbl.add stats "tasks_cancelled" (float_of_int cancelled);

  (* Attention statistics *)
  let (total_sti, total_lti, total_vlti, node_count) = Ecan.get_attention_statistics engine.ecan_allocator in
  Hashtbl.add stats "total_sti" total_sti;
  Hashtbl.add stats "total_lti" total_lti;
  Hashtbl.add stats "total_vlti" total_vlti;
  Hashtbl.add stats "attention_node_count" (float_of_int node_count);

  (* PLN statistics *)
  let inference_count = List.length (Reasoning.get_pln_inference_history engine.pln_engine) in
  Hashtbl.add stats "inference_count" (float_of_int inference_count);

  (* Meta-cognitive statistics *)
  let metacog_state = Metacognition.get_metacognitive_state engine.metacognitive_engine in
  Hashtbl.add stats "cognitive_load" metacog_state.cognitive_load;
  Hashtbl.add stats "confidence_level" metacog_state.confidence_level;

  stats

(** Export to Scheme format *)
let export_to_scheme engine =
  let buffer = Buffer.create 1024 in

  (* Export header *)
  Buffer.add_string buffer ";; Cognitive Engine Export\n";
  Buffer.add_string buffer ";; Generated by OpenRocq Cognitive Engine Plugin\n\n";

  (* Export nodes *)
  Buffer.add_string buffer "(define nodes\n  '(\n";
  Hashtbl.iter (fun id node ->
    Buffer.add_string buffer (Printf.sprintf "    (%d \"%s\" %f %f %f)\n"
      id node.name node.attention.sti node.attention.lti node.confidence)
  ) engine.atomspace.nodes;
  Buffer.add_string buffer "  ))\n\n";

  (* Export links *)
  Buffer.add_string buffer "(define links\n  '(\n";
  Hashtbl.iter (fun id link ->
    let sources = String.concat " " (List.map string_of_int link.source_nodes) in
    let targets = String.concat " " (List.map string_of_int link.target_nodes) in
    Buffer.add_string buffer (Printf.sprintf "    (%d (%s) (%s) \"%s\")\n"
      id sources targets link.link_type)
  ) engine.atomspace.links;
  Buffer.add_string buffer "  ))\n\n";

  (* Export helper functions *)
  Buffer.add_string buffer "(define (get-node-by-id id)\n";
  Buffer.add_string buffer "  (find (lambda (node) (= (car node) id)) nodes))\n\n";

  Buffer.add_string buffer "(define (get-links-by-type type)\n";
  Buffer.add_string buffer "  (filter (lambda (link) (string=? (cadddr link) type)) links))\n\n";

  Buffer.add_string buffer "(define (get-connected-nodes node-id)\n";
  Buffer.add_string buffer "  (append-map (lambda (link)\n";
  Buffer.add_string buffer "    (let ((sources (cadr link)) (targets (caddr link)))\n";
  Buffer.add_string buffer "      (cond\n";
  Buffer.add_string buffer "        ((member node-id sources) targets)\n";
  Buffer.add_string buffer "        ((member node-id targets) sources)\n";
  Buffer.add_string buffer "        (else '())))) links))\n\n";

  Buffer.contents buffer

(** Import from Scheme format *)
let import_from_scheme engine scheme_code =
  (* This is a simplified stub for Scheme import *)
  (* In a real implementation, you would parse the Scheme code *)
  (* and reconstruct the atomspace from it *)
  Printf.printf "Importing from Scheme: %s\n" (String.sub scheme_code 0 (min 100 (String.length scheme_code)));
  Printf.printf "Import functionality is a stub - would parse and load Scheme data\n"

(** Get engine status *)
let get_engine_status engine =
  let stats = get_engine_statistics engine in
  let node_count = Hashtbl.find stats "node_count" in
  let link_count = Hashtbl.find stats "link_count" in
  let running_tasks = Hashtbl.find stats "tasks_running" in
  let cognitive_load = Hashtbl.find stats "cognitive_load" in

  Printf.sprintf "CognitiveEngine Status:\n  Nodes: %.0f\n  Links: %.0f\n  Running Tasks: %.0f\n  Cognitive Load: %.2f"
    node_count link_count running_tasks cognitive_load

(** Shutdown engine *)
let shutdown_engine engine =
  (* Cancel all pending tasks *)
  let pending_tasks = Taskscheduler.get_tasks_by_state engine.task_scheduler Taskscheduler.Pending in
  List.iter (fun task ->
    ignore (Taskscheduler.cancel_task engine.task_scheduler task.id)
  ) pending_tasks;

  (* Perform final attention decay *)
  Ecan.decay_attention_values engine.ecan_allocator;

  (* Clear data structures *)
  Hashtbl.clear engine.atomspace.nodes;
  Hashtbl.clear engine.atomspace.links;
  Hashtbl.clear engine.atomspace.tensors;

  Printf.printf "Cognitive engine shutdown complete\n"
